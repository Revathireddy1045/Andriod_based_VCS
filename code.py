# -*- coding: utf-8 -*-
"""Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13R_wmTsM8h3hCeGaaFcmWZGeVf6mmUxA
"""

#insert your API key


import requests
from itertools import combinations
from scipy.stats import norm
import webbrowser  # Import webbrowser to open URLs
import urllib.parse
from geopy.distance import geodesic
from geopy.geocoders import Nominatim

# Function to calculate direct travel time between two locations
def calculate_travel_time(origin, destination, api_key):
    url = f"https://maps.googleapis.com/maps/api/distancematrix/json?units=metric&origins={origin}&destinations={destination}&key={api_key}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        if data["status"] == "OK":
            travel_time = int(data["rows"][0]["elements"][0]["duration"]["value"]) / 60  # Travel time in minutes
            return travel_time
        else:
            print(f"Error: {data['error_message']}")
    else:
        print(f"Error: Non-successful status code {response.status_code}")
        print(f"Response content: {response.text}")  # Print the response content for debugging
    return None


# Function to calculate expected utility
def calculate_expected_utility(vehicle_id_utility, vehicle_ids, total_num_poi, poi_location, api_key, costs, reward):
    # Calculate sensing times for all vehicles
    sensing_times = calculate_sensing_times(vehicle_ids, costs, reward)

    probability_values = calculate_probability_values(vehicle_id_utility, vehicle_ids, total_num_poi)
    probability_distributions = {}
    utilities = {}

    # Compute probability distributions for each vehicle ID
    for vehicle_id in vehicle_ids:
        probability_distributions[vehicle_id] = calculate_probability_distribution(
            vehicle_id_utility, vehicle_id, vehicle_ids, vehicle_addresses, poi_location, std_deviations, buffer_interval, api_key
        )

    num_vehicles = len(vehicle_ids)
    expected_utility = 0

    # Calculate utility for each subset of vehicles
    for r in range(1, num_vehicles + 1):
        for subset in combinations(vehicle_ids, r):
            if vehicle_id_utility in subset:
                subset_costs = [costs[vehicle_ids.index(vid)] for vid in subset]
                utilities[subset] = calculate_utility(subset, vehicle_id_utility, reward, subset_costs, sensing_times)

                prod_prod = 1
                comp_prod = 1
                for i in vehicle_ids:
                    if i != vehicle_id_utility:
                        if probability_distributions[i] is not None:
                            if i in subset:
                                prod_prod *= probability_values[i] * probability_distributions[i]
                            else:
                                comp_prod *= (1 - probability_values[i]) * (1 - probability_distributions[i])
                expected_utility += prod_prod * comp_prod * utilities[subset]

    return expected_utility

# Function to calculate probability values
def calculate_probability_values(vehicle_id_utility, vehicle_ids, total_num_poi):
    probability_values = {}
    probability_values[vehicle_id_utility] = 1
    probability_value_not_utility = 1 / (total_num_poi + 1)
    for vehicle_id in vehicle_ids:
        if vehicle_id != vehicle_id_utility:
            probability_values[vehicle_id] = probability_value_not_utility
    return probability_values

# Function to get vehicle addresses
def get_vehicle_address(vehicle_id, vehicle_ids, vehicle_addresses):
    try:
        index = vehicle_ids.index(vehicle_id)
        return vehicle_addresses[index]
    except ValueError:
        print(f"Error: Vehicle with ID {vehicle_id} not found.")
        return None

# Function to get arrival times using Google Maps API
def get_arrival_times(vehicle_id, other_vehicle_id, vehicle_ids, vehicle_addresses, poi_location, api_key):
    vehicle_address = get_vehicle_address(vehicle_id, vehicle_ids, vehicle_addresses)
    other_vehicle_address = get_vehicle_address(other_vehicle_id, vehicle_ids, vehicle_addresses)

    if vehicle_address is None or other_vehicle_address is None:
        return None, None

    url = f"https://maps.googleapis.com/maps/api/distancematrix/json?units=metric&origins={vehicle_address}|{other_vehicle_address}&destinations={poi_location}&key={api_key}"

    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        if data["status"] == "OK":
            arrival_time_vehicle = int(data["rows"][0]["elements"][0]["duration"]["value"]) / 60  # Arrival time in minutes
            arrival_time_other_vehicle = int(data["rows"][1]["elements"][0]["duration"]["value"]) / 60
            return arrival_time_vehicle, arrival_time_other_vehicle
        else:
            print(f"Error: {data['error_message']}")
    else:
        print(f"Error: Unable to fetch data for vehicles {vehicle_id} and {other_vehicle_id}")

    return None, None

# Function to calculate probability distribution
def calculate_probability_distribution(vehicle_id_utility, vehicle_id_other, vehicle_ids, vehicle_addresses, poi_location, std_deviations, buffer_interval, api_key):
    arrival_time_vehicle, arrival_time_other_vehicle = get_arrival_times(vehicle_id_utility, vehicle_id_other, vehicle_ids, vehicle_addresses, poi_location, api_key)

    if arrival_time_vehicle is None or arrival_time_other_vehicle is None:
        return None

    mean_difference = arrival_time_vehicle - arrival_time_other_vehicle
    std_dev = (std_deviations[vehicle_id_utility] ** 2 + std_deviations[vehicle_id_other] ** 2) ** 0.5

    z_upper = (buffer_interval - mean_difference) / std_dev
    z_lower = (-buffer_interval - mean_difference) / std_dev
    prob_upper = norm.cdf(z_upper)
    prob_lower = norm.cdf(z_lower)
    probability = prob_upper - prob_lower

    return probability

# Function to calculate sensing times
def calculate_sensing_times(vehicle_ids, costs, reward):
    sorted_indices = sorted(range(len(costs)), key=lambda k: costs[k])
    W = [(vehicle_ids[i], costs[i]) for i in sorted_indices]

    if len(W) < 2:
        print("Not enough vehicles to perform calculations.")
        return {vid: 0 for vid, _ in W}

    H = [W[0], W[1]]
    i = 2

    while i < len(W) and W[i][1] <= (W[i][1] + sum(cost for _, cost in H)) / len(H):
        H.append(W[i])
        i += 1

    sensing_times = {}
    sum_k_H = sum(cost for _, cost in H)
    for vehicle_id, cost in W:
        if (vehicle_id, cost) in H:
            ti = (((len(H) - 1) * reward) / sum_k_H) * (1 - (((len(H) - 1) * cost) / sum_k_H))
        else:
            ti = 0
        sensing_times[vehicle_id] = ti

    return sensing_times

# Function to calculate utility
def calculate_utility(vehicle_ids, known_vehicle_id, reward, costs, sensing_times):
    sensing_time_known = sensing_times.get(known_vehicle_id, 0)
    cost_known = costs[vehicle_ids.index(known_vehicle_id)]
    total_sensing_time = sum(sensing_times.get(vid, 0) for vid in vehicle_ids)

    if len(vehicle_ids) == 1:
        utility = reward - cost_known * sensing_time_known
    else:
        utility = (sensing_time_known / total_sensing_time) * reward - cost_known * sensing_time_known

    return utility

# Function to calculate final POI sensing plan
def calculate_final_poi_sensing_plan(vehicle_id, poi_location, poi_vehicles, costs, reward):
    # Get vehicle IDs associated with the POI
    poi_vehicle_ids = [vid for vid, _ in poi_vehicles.get(poi_location, [])]

    # Include the vehicle_id for which we are calculating the sensing plan
    vehicle_ids_for_poi = poi_vehicle_ids + [vehicle_id]

    # Get costs for vehicles associated with the POI
    vehicle_costs_poi = {vid: cost for vid, cost in poi_vehicles.get(poi_location, [])}

    # Include cost for the vehicle_id itself, if not already present
    if vehicle_id not in vehicle_costs_poi:
        vehicle_costs_poi[vehicle_id] = costs[vehicle_ids.index(vehicle_id)]

    # Get costs for all vehicle IDs for the POI
    vehicle_costs = [vehicle_costs_poi[vid] for vid in vehicle_ids_for_poi]

    # Calculate sensing times based on these costs
    full_sensing_times = calculate_sensing_times(vehicle_ids_for_poi, vehicle_costs, reward)

    # Return the full sensing times
    return full_sensing_times

# Function to calculate final POI utility
def calculate_final_poi_utility(vehicle_id, poi_location, poi_vehicles, costs, reward):
    full_sensing_plan = calculate_final_poi_sensing_plan(vehicle_id, poi_location, poi_vehicles, costs, reward)
    vehicle_ids_for_poi = [vid for vid, _ in poi_vehicles.get(poi_location, [])] + [vehicle_id]
    final_utility = calculate_utility(vehicle_ids_for_poi, vehicle_id, reward, costs, full_sensing_plan)
    return final_utility

# Function to calculate cost using Google Maps Geocoding API
def cost_calculation(location_1, location_2, api_key):
    def get_coordinates(location):
        url = f"https://maps.googleapis.com/maps/api/geocode/json?address={location}&key={api_key}"
        response = requests.get(url)
        if response.status_code != 200:
            raise ValueError(f"Error in request: {response.status_code}")
        data = response.json()
        if data['status'] != 'OK':
            raise ValueError(f"Geocoding failed: {data['status']}")
        loc = data['results'][0]['geometry']['location']
        return loc['lat'], loc['lng']

    try:
        coords_1 = get_coordinates(location_1)
        coords_2 = get_coordinates(location_2)

        distance = geodesic(coords_1, coords_2).miles
        cost = distance * 0.5  # Assuming cost = distance * 0.5
        return cost
    except Exception as e:
        print(f"Error in cost calculation: {e}")
        return None

# Function to generate a Google Maps URL to visualize the trajectory
def generate_google_maps_url(visiting_list):
    base_url = "https://www.google.com/maps/dir/?api=1"
    origin = urllib.parse.quote(visiting_list[0])  # Starting point
    destination = urllib.parse.quote(visiting_list[-1])  # Final destination

    if len(visiting_list) > 2:
        waypoints = '|'.join(urllib.parse.quote(location) for location in visiting_list[1:-1])  # Intermediate waypoints
        map_url = f"{base_url}&origin={origin}&destination={destination}&waypoints={waypoints}&travelmode=driving"
    else:
        # If there are no intermediate waypoints, skip them
        map_url = f"{base_url}&origin={origin}&destination={destination}&travelmode=driving"

    return map_url

# Main code to generate vehicle visiting list for each vehicle
vehicle_ids = [11, 22, 33, 44, 55]
total_num_poi = 20
vehicle_addresses = [
    '3716 Morgan Combee Rd, Lakeland, FL',
    '1444 W Highland St, Lakeland, FL',
    '111 Lake Hollingsworth Dr, Lakeland, FL',
    '2222 Interstate Dr, Lakeland, FL',
    '3030 E Lake Parker Dr, Lakeland, FL'

]
poi_locations = [
    '3501 Florida Ave S, Lakeland, FL',
    '3570 Harden Blvd, Lakeland, FL',
    '2120 Harden Blvd, Lakeland, FL',
    '1030 Lakeland Hills Blvd, Lakeland, FL',
    '700 Galvin Dr, Lakeland, FL',
    '2121 New Tampa Hwy, Lakeland, FL',
    '1405 N Combee Rd, Lakeland, FL',
    '1401 E Gary Rd, Lakeland, FL',
    '3200 Lakeland Hills Blvd, Lakeland',
    '5275 Long Lake Cir, Lakeland',
    '3030 Reynolds Rd, Lakeland, FL',
    '72 Ave E N, Auburndale, FL',
    '3755 Tenoroc Mine Rd, Lakeland, FL',
    '5341 Bloomfield Blvd, Lakeland, FL',
    '1606 Tall Pines Trail, Lakeland, FL',
    '1475 Airport Rd, Lakeland, FL',
    '5300 Allen K Breed Hwy, Lakeland, FL',
    '4142 S Polk Ave, Lakeland, FL',
    '915 N Virginia Ave, Lakeland, FL',
    '2323 Hollingsworth Hill Ave, Lakeland, FL'


]
poi_vehicles = {
    '3501 Florida Ave S, Lakeland, FL': [(12, 3), (13, 2)],
    '3570 Harden Blvd, Lakeland, FL': [(23, 3), (24, 2)],
    '2120 Harden Blvd, Lakeland, FL': [(32, 3), (34, 2)],
    '1030 Lakeland Hills Blvd, Lakeland, FL': [(41, 3), (42, 2)],
    '700 Galvin Dr, Lakeland, FL': [(51, 3), (52, 2)],
    '2121 New Tampa Hwy, Lakeland, FL': [(61, 3), (62, 2)],
    '1405 N Combee Rd, Lakeland, FL': [(71, 3), (72, 2)],
    '1401 E Gary Rd, Lakeland, FL': [(81, 3), (82, 2)],
    '3200 Lakeland Hills Blvd, Lakeland': [(91, 3), (92, 2)],
    '5275 Long Lake Cir, Lakeland': [(101, 3), (102, 3)],
    '3030 Reynolds Rd, Lakeland, FL': [(112, 3), (113, 2)],
    '72 Ave E N, Auburndale, FL': [(121, 3), (123, 2)],
    '3755 Tenoroc Mine Rd, Lakeland, FL': [(131, 3), (132, 2)],
    '5341 Bloomfield Blvd, Lakeland, FL': [(141, 3), (142, 2)],
    '1606 Tall Pines Trail, Lakeland, FL': [(151, 3), (152, 2)],
    '1475 Airport Rd, Lakeland, FL': [(161, 3), (162, 2)],
    '5300 Allen K Breed Hwy, Lakeland, FL': [(171, 3), (172, 2)],
    '4142 S Polk Ave, Lakeland, FL': [(181, 3), (182, 2)],
    '915 N Virginia Ave, Lakeland, FL': [(191, 3), (192, 2)],
    '2323 Hollingsworth Hill Ave, Lakeland, FL': [(201, 3), (202, 2)]

}




reward = 100
api_key = "your_API_key"
destination_location = '3685 Victoria Manor Dr, Lakeland, FL 33805'
initial_traveling_time_limit = 30  # in minutes
buffer_interval = 200  # Example buffer interval in minutes
std_deviations = {11: 5, 22: 5, 33: 5, 44: 5, 55: 5}

# Create an empty dictionary to store final utilities for each vehicle
final_utilities_per_poi = {}

# Create an empty dictionary to store visiting lists for each vehicle
visiting_lists = {}

for vehicle_id in vehicle_ids:
    traveling_time_limit = initial_traveling_time_limit
    current_location = vehicle_addresses[vehicle_ids.index(vehicle_id)]
    visiting_list = [current_location]
    utilities_list = ["N/A"]  # Initial location gets "N/A" for utility


    while True:
        max_utility = -float('inf')
        best_poi = None
        best_arrival_time = None

        for poi_location in poi_locations:
            if poi_location not in visiting_list:
                try:
                    # Generate the cost list for all vehicles
                    costs = []
                    for v_id, v_address in zip(vehicle_ids, vehicle_addresses):
                        if v_id == vehicle_id:
                            # For the current vehicle, calculate the cost from the current location
                            try:
                                cost = cost_calculation(current_location, poi_location, api_key)
                            except Exception as e:
                                print(f"Error calculating cost for {poi_location} from {current_location}: {e}")
                                continue  # Skip to the next POI if cost calculation fails
                        else:
                            # For other vehicles, calculate the cost from their initial locations
                            try:
                                cost = cost_calculation(v_address, poi_location, api_key)
                            except Exception as e:
                                print(f"Error calculating cost for {poi_location} from {v_address}: {e}")
                                continue
                        costs.append(cost)





                    # Calculate expected utility and arrival time
                    expected_utility = calculate_expected_utility(
                        vehicle_id, vehicle_ids, total_num_poi, poi_location, api_key, costs, reward
                    )
                    print(f"Expected Utility for POI {poi_location}: {expected_utility}")
                    arrival_time = calculate_travel_time(current_location, poi_location, api_key)
                    if expected_utility > max_utility and arrival_time is not None and arrival_time <= traveling_time_limit:
                        max_utility = expected_utility
                        best_poi = poi_location
                        best_costs = costs
                        best_arrival_time = arrival_time
                except Exception as e:
                    print(f"Error calculating expected utility for POI {poi_location}: {e}")


        if best_poi is None or best_arrival_time is None:
            break


        # Update visiting list and remaining time
        visiting_list.append(best_poi)
        traveling_time_limit -= best_arrival_time
        current_location = best_poi

        if traveling_time_limit <= 0:
            break

        # Create an empty dictionary to store final utilities for each vehicle
        final_utilities = {}

        # Calculate final sensing plan and utility for the best POI
        final_sensing_plan = calculate_final_poi_sensing_plan(vehicle_id, best_poi, poi_vehicles, costs, reward)
        final_utility = calculate_final_poi_utility(vehicle_id, best_poi, poi_vehicles, costs, reward)

        # Store the final utility for the current POI in the utilities list
        utilities_list.append(final_utility)

        # Display costs for all vehicles at the best POI
        print(f"\nCosts list for POI {best_poi}: {best_costs}")
        # Format output to display only the current vehicle's sensing plan
        print(f"Vehicle {vehicle_id} - Final Sensing Plan at POI {best_poi}: {final_sensing_plan[vehicle_id]:.2f}")
        print(f"Vehicle {vehicle_id} - Final Utility at POI {best_poi}: {final_utility:.2f}\n")


    if traveling_time_limit > 0:
        visiting_list.append(destination_location)  # Add final destination
        utilities_list.append("N/A")  # No utility for the final destination

    visiting_lists[vehicle_id] = visiting_list
    final_utilities_per_poi[vehicle_id] = utilities_list  # Store utilities for all POIs


print("\nAll Vehicle Visiting Lists:")
for vehicle_id, visiting_list in visiting_lists.items():
    print(f"Vehicle {vehicle_id}:")
    for location in visiting_list:
        print(f"  - {location}")

for vehicle_id in visiting_lists.keys():
    print(f"\nVehicle {vehicle_id}:")
    if vehicle_id in final_utilities_per_poi:  # Check if the vehicle ID exists
        for i, location in enumerate(visiting_lists[vehicle_id]):
            # Print each location along with its corresponding utility value
            utility_value = final_utilities_per_poi[vehicle_id][i] if i < len(final_utilities_per_poi[vehicle_id]) else "N/A"
            print(f"  - {location} --- {utility_value}")


# Set to store unique POIs visited
visited_pois = set()

# Loop through all vehicle visiting lists
for vehicle_id, visiting_list in visiting_lists.items():
    for location in visiting_list:
        # If the location is in the list of POIs, add it to the set
        if location in poi_locations:
            visited_pois.add(location)

# The number of unique POIs visited
count_visited_pois = len(visited_pois)

print(f"Number of POIs visited at least once: {count_visited_pois}")

# After generating visiting lists, display the visiting list and open it in Google Maps
input_vehicle_id = int(input("Enter the Vehicle ID to get the visiting list: "))

# Display the visiting list for the specified vehicle ID
if input_vehicle_id in visiting_lists:
    print(f"\nVehicle {input_vehicle_id} visiting list:")
    for location in visiting_lists[input_vehicle_id]:
        print(f"  - {location}")

    # Generate and open the Google Maps URL
    google_maps_url = generate_google_maps_url(visiting_lists[input_vehicle_id])
    print(f"\nGoogle Maps Trajectory URL: {google_maps_url}")
    webbrowser.open(google_maps_url)  # Open the URL in the default browser
else:
    print(f"Vehicle ID {input_vehicle_id} not found.")